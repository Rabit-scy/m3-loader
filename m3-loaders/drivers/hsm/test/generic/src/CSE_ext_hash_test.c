/*
    SPC5-CRYPTO - Copyright (C) 2015 STMicroelectronics

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
 * @file    CSE_ext_RSA_PKCS_test.c
 * @brief   pkcs signature tests
 * @details
 *
 *
 * @addtogroup CSE_driver_test
 * @{
 */
#include "config.h"
#include "serialprintf.h"

#include "cse_types.h"
#include "CSE_ext_hash.h"
#include "CSE_Constants.h"
#include "CSE_RNG.h"
#include "string.h"

#include "err_codes.h"
#ifdef PERF_MEASURMENT
#include "pit_perf_meas.h"
#endif

#define print_buffer( cmt, buf, size)  display_buf( (cmt), (uint8_t*)(buf), (size) )

const ALIGN uint8_t input_1[] = {0x46,0x78,0x79,0x2A,0x99,0x79,0x73,0x05,0xE9,0x04,0xB2,0x4D,0x82,0x14,0x9A,0x43,0x5E,0xA6,0xAF,0x96,0x80,0x48,0xCB,0x49,0x41,0xBA,0x11,0xA7,
                           0xB6,0x24,0x7C,0x92,0x8D,0xBA,0x96,0x91,0x4F,0x9A,0xA6,0x1D,0x7B,0x37,0x99,0x7E,0xC6,0xBE,0x4F,0xC5,0x58,0x94,0xF9,0x2A,0xC4,0x09,0x68,0xF7,
                           0xAA,0xE7,0xD4,0xE9,0xEB,0x21,0x6A,0x93,0x1D};

const ALIGN uint8_t input_2[] = {0x3B};

const ALIGN uint8_t input_3[] = {0x97,0xC6,0x65,0x99,0x8B,0x25,0xC8,0x35,0x51,0xE0,0x77,0x6F,0x47,0x42,0x8D,0x32,0x34,0x7D,0x59,0x3E,0x2D,0x58,0x01,0xD6,0x37,0x80,0xD5,0x95,
                           0xEE,0x53,0xEC,0x37,0xAD,0xDF,0xD0,0x70,0xC3,0xA8,0xFA,0xED,0x81,0xA9,0x1B,0x81,0xE2,0x81,0xD9,0x4B,0x41,0x7B,0xAC,0x5F,0x3D,0x08,0xB8,0xA6,
                           0x88,0x7F,0x62,0xAC,0x90,0xEF,0x63,0x1F,0x04,0x17,0x78,0x93,0x56,0x8C,0xA4,0x08,0xCC,0xD3,0x94,0xC0,0xA6,0x36,0xC6,0x16,0x5E,0xB0,0x54,0xEC,
                           0x83,0x9E,0x33,0x74,0x0A,0x7F,0x21,0xFD,0xF5,0xB4,0x20,0x50,0x1B,0x45,0xE0,0x5E,0xAD,0xFD,0x08,0x1A,0xAC,0x98,0x19,0x8B,0x0A,0x4C,0xA2,0x81,
                           0xF5,0x33,0xD4,0x58,0xD0,0xEF,0x23,0xCD,0x17,0xF7,0x04,0xBC,0xC2,0x50,0x75,0x78};

#ifdef INCLUDE_HMAC
const ALIGN uint8_t key_1[] = {0x1E,0x59,0x2B,0x27,0x1E,0xC1,0x64,0x43,0xA4,0x79,0x8F,0x33,0xAA,0x34,0x03,0xE4,0x70,0x34,0xD2,0x2E,0xCE,0x1A,0x3D};
const ALIGN uint8_t key_2[] = {0xE9,0x6D,0xF5,0xBF,0xD2,0x0B,0x49,0xCD,0x51,0x6C,0x70,0x66,0x10,0x87,0x3A,0xDF,0xBA,0xC4,0x72,0x28,0xDC,0x30,0xA8,0xCF,0x41,0xA4,0x40,0x46,
                         0xE9,0xEB,0x8A,0xDA,0xC4,0x47,0x6B,0x3D,0x2A,0x73,0xA8,0x47,0x19,0x65,0x1C,0x9D,0xB8,0x5C,0x08,0xAF,0x2A,0x53,0x4D,0x57,0x96,0xC1,0x95,0xC4,
                         0x31,0xA4,0x46,0x67,0x0A,0x8D,0x6E,0xF1,0x9D};
const ALIGN uint8_t key_3[] = {0x4E,0xB7,0x07,0x7C,0x46,0xBC,0xEB,0x37,0x4E,0x97,0x61,0xE5,0xCE,0xA6,0x4B,0x97,0xA4,0xF9,0x61,0x11,0x52,0x28,0x62,0x6D,0xFD,0xFA,0x58,0x84,
                             0x66,0x73,0xBE,0x2E};
#endif

const ALIGN uint8_t sha1_hash[3][CRL_SHA1_SIZE] = {{0x19,0x8A,0x19,0x3B,0x5A,0xDC,0x28,0xED,0x51,0x07,0x15,0x55,0x2A,0xC0,0x73,0x33,0x33,0xAC,0x5F,0x60},
                                                {0x2D,0x14,0xAB,0x97,0xCC,0x3D,0xC2,0x94,0xC5,0x1C,0x0D,0x68,0x14,0xF4,0xEA,0x45,0xF4,0xB4,0xE3,0x12},
                                             {0x11,0xE8,0x6A,0x2B,0x8D,0x79,0x05,0xBB,0xF4,0xE0,0xE7,0xB3,0x7F,0xE3,0x3B,0x5A,0xF6,0x5D,0xD1,0x27}};

#ifdef INCLUDE_HMAC
const ALIGN uint8_t sha1_hmac[3][CRL_SHA1_SIZE] = {{0xE7,0x26,0x38,0xC1,0xF2,0xFE,0x00,0x24,0x73,0x2F,0x7A,0x49,0x45,0x5B,0xF6,0x58,0xB7,0x37,0x87,0xA2},
                                                 {0x95,0x1E,0x84,0xDE,0xCA,0x03,0xB3,0xF5,0x28,0x7F,0x2E,0xDE,0xDA,0x49,0xCE,0x22,0x08,0x4A,0x13,0xD8},
                                             {0x00,0x9B,0xE7,0xB2,0xC5,0xD2,0x0A,0x1C,0xFD,0x93,0x53,0x11,0xB4,0x5A,0x8B,0x73,0xC6,0x6A,0x96,0x63}};
#endif

#ifdef INCLUDE_SHA224
const ALIGN uint8_t sha224_hash[3][CRL_SHA224_SIZE] = {{0xFA,0x63,0x9A,0x83,0x38,0x71,0xE9,0x9A,0xA1,0x43,0x24,0xA5,0x1A,0x0F,0x4A,0xF9,0x17,0xE1,0x0A,0xCA,0x8D,0x59,0xF8,0xFE,0xF2,0x57,0x68,0xB6},
                                                     {0x1E,0x02,0x70,0x7A,0x0B,0x8E,0xF3,0x99,0x08,0xB2,0xF2,0x9B,0x98,0x14,0x37,0x8D,0x67,0xAC,0xFE,0x52,0x2B,0x7E,0x96,0x86,0x40,0xF8,0x60,0xA5},
                                                 {0x28,0x71,0x1D,0x08,0xF6,0x0A,0x55,0xCA,0xCB,0xCF,0x71,0x26,0x8F,0xF5,0xEA,0xD8,0x4D,0x6D,0x75,0xDE,0xA1,0xD3,0x1C,0xF5,0xD1,0x7A,0xB0,0xB6}};

#ifdef INCLUDE_HMAC
const ALIGN uint8_t sha224_hmac[3][CRL_SHA224_SIZE] = {{0x01,0x25,0x3E,0x6E,0x62,0xE1,0x31,0xF9,0x54,0xAE,0xA9,0x4C,0x18,0x2C,0x2A,0x02,0xBC,0x7C,0x81,0xD0,0xA3,0xCF,0xDC,0xC9,0x8C,0x70,0x28,0x74},
                                                     {0xB7,0x9E,0x12,0xE4,0xB4,0xAB,0xBA,0x03,0x69,0x1F,0xA2,0x1F,0xD2,0x6D,0x4A,0xD7,0x4A,0x06,0x0B,0xF5,0x50,0x7C,0x21,0x53,0x4D,0xCD,0x7A,0x9E},
                                                 {0x0C,0xB0,0xA9,0x31,0x78,0x00,0xC3,0x97,0xCF,0x78,0x34,0xCA,0xB0,0xAF,0x5E,0xC9,0x44,0x1B,0xFA,0x9E,0x68,0xE1,0x9F,0x6E,0x4E,0xAA,0x43,0xD9}};
#endif
#endif
#ifdef INCLUDE_SHA256
const ALIGN uint8_t sha256_hash[3][CRL_SHA256_SIZE] = {{0x11,0xA4,0xB1,0xF2,0xC4,0x6C,0x88,0x1B,0x08,0x53,0x96,0xA7,0x9F,0x58,0x1F,0x4B,0x11,0xA6,0x01,0x48,0xCF,0x23,0x99,0xD4,0xE6,0x15,0x4B,0x47,
                                                     0x39,0xAE,0xA2,0x96},
                                                     {0x41,0xB8,0x05,0xEA,0x7A,0xC0,0x14,0xE2,0x35,0x56,0xE9,0x8B,0xB3,0x74,0x70,0x2A,0x08,0x34,0x42,0x68,0xF9,0x24,0x89,0xA0,0x2F,0x08,0x80,0x84,
                                                     0x93,0x94,0xA1,0xE4},
                                                 {0x96,0x39,0x47,0x25,0x58,0xC3,0x55,0x04,0x72,0x95,0x63,0x15,0xB7,0x63,0x02,0xB6,0x06,0xC2,0x7E,0x68,0xEC,0x3A,0x88,0x7B,0xE4,0xB9,0x87,0xFB,
                                                 0xAD,0x90,0xFD,0x89}};
#ifdef INCLUDE_HMAC
const ALIGN uint8_t sha256_hmac[3][CRL_SHA256_SIZE] = {{0xEF,0xDE,0x1F,0x62,0xC7,0x98,0x63,0x72,0x9D,0xDB,0x5A,0x34,0x18,0xB1,0x4D,0xD5,0x1B,0x9B,0xA8,0xB6,0xEB,0x33,0x22,0xF9,0x35,0xFB,0xC4,0x5D,
                                                     0xD1,0xC7,0xA6,0xD0},
                                                     {0xD0,0xF3,0x44,0xF0,0x11,0xB9,0x8A,0x7B,0xCA,0x1A,0x7E,0xEE,0x85,0x6D,0x17,0x3D,0x0B,0xDE,0x06,0x0B,0xC1,0x0E,0x84,0x13,0x4F,0x16,0xF3,0x08,
                                                   0xF0,0x05,0x32,0xB6},
                                                 {0xAF,0x00,0xED,0xC1,0xF5,0xC4,0x75,0x29,0x23,0x26,0xB2,0xD7,0xB2,0x2D,0x3C,0x34,0x3D,0xA6,0x2A,0x0E,0xF9,0x3F,0x8C,0xCC,0xC3,0xE2,0xAA,0xBA,
                                                 0x50,0xCE,0x64,0xFD}};
#endif
#endif
#ifdef INCLUDE_SHA384
const ALIGN uint8_t sha384_hash[3][CRL_SHA384_SIZE] = {{0x34,0x96,0xB4,0x15,0xD0,0x74,0x0E,0x92,0xD1,0x7B,0x1C,0xA7,0x96,0xA3,0x13,0x8C,0xAB,0x2D,0xE4,0x81,0x7F,0x0D,0x5A,0x23,0x25,0x19,
                                                 0x55,0xD8,0x7F,0xA9,0xB8,0xDB,0x49,0x29,0xA2,0x08,0xDE,0xCE,0xCA,0x0C,0x8A,0x32,0xD2,0x7C,0x38,0x29,0x3D,0x73},
                                                  {0xE8,0x24,0xFE,0x5A,0x8E,0x6C,0xD5,0xE2,0xAC,0x09,0x54,0x25,0x06,0xCC,0xF3,0xC3,0xAD,0x34,0xD1,0xF7,0x50,0x3A,0xD1,0x78,0x67,0xEA,0x48,
                                                  0xF4,0x53,0xC8,0xE1,0xEA,0x9F,0x6D,0xFD,0xA7,0x69,0x15,0x46,0xF1,0x3C,0x99,0x13,0x6F,0xD4,0xA9,0xBD,0x13},
                                                 {0xE3,0xF2,0xBD,0xD9,0xE9,0x5C,0xB9,0xA6,0x56,0x1E,0x02,0x18,0xCA,0x6C,0x79,0x62,0xC2,0x77,0x99,0xBD,0x08,0x62,0xE3,0x39,0xA4,0x36,0x64,
                                                 0x89,0xCB,0x69,0xA5,0x8C,0x84,0xCB,0x77,0xFF,0xC1,0x61,0x2B,0x25,0x29,0x1D,0x46,0xDF,0x98,0x75,0x7C,0x2B}};
#ifdef INCLUDE_HMAC
const ALIGN uint8_t sha384_hmac[3][CRL_SHA384_SIZE] = {{0x0A,0xFC,0x41,0x77,0xB1,0x55,0x1E,0xA2,0xBD,0xDE,0x73,0x2B,0x57,0x75,0xA1,0xD1,0xD7,0xDF,0xCA,0xB4,0x50,0xC1,0x6E,0xE2,0x5B,0x72,
                                                 0x26,0xBD,0x5B,0x61,0x25,0xDF,0x82,0xBC,0x09,0x66,0xC5,0xB1,0x0F,0x6D,0x28,0x72,0x73,0x79,0xA5,0xFE,0xD1,0xD4,},
                                                 {0x12,0x63,0xC9,0xF1,0x98,0x12,0x27,0x8A,0xAA,0x3E,0xDD,0xE3,0x40,0xC4,0x82,0x43,0xA2,0x3B,0x51,0x95,0xFA,0xEA,0x8B,0x41,0xC8,0x6A,
                                                 0xA9,0xD6,0x1E,0x07,0x38,0x52,0x33,0x82,0xBA,0x83,0x2F,0x8F,0xF8,0xEC,0x3E,0x5E,0x2F,0x9B,0x77,0x6A,0xAA,0xAE,},
                                                 {0x1A,0xEF,0xCB,0x6C,0xE2,0x30,0xDA,0x51,0x8F,0x75,0x9B,0xC4,0xEA,0xFE,0x8A,0x38,0x50,0xC7,0x5F,0x16,0x19,0x76,0xDF,0x5A,0x58,0x2E,
                                                 0x34,0xF9,0xAC,0x09,0x73,0x64,0x72,0x96,0x2A,0x48,0xB6,0xCC,0xFD,0x10,0x68,0x9A,0xF6,0x1D,0x00,0xF4,0x47,0x9A,}};
#endif
#endif
#ifdef INCLUDE_SHA512
const ALIGN uint8_t sha512_hash[3][CRL_SHA512_SIZE] = {{0xCA,0x70,0x9D,0x9C,0x8D,0xE9,0x46,0x18,0x8A,0xFE,0x9B,0x84,0xFC,0x31,0xE1,0xD9,0xAD,0xF0,0xC0,0xFC,0xA2,0x4F,0x0C,0x0D,0xB3,0x05,0x36,0x58,
                                                  0xD1,0x77,0x54,0x11,0x66,0x90,0x00,0x30,0xC2,0xAA,0xFC,0xE5,0xAF,0x41,0xF4,0xA9,0x4E,0x47,0x81,0xFA,0x69,0x09,0x7B,0x4F,0xCF,0xB2,0xF5,0xF0,
                                                 0xA1,0xBB,0x7A,0x64,0x72,0x85,0x9E,0xEE},
                                                 {0xE2,0x8E,0x54,0x7F,0x81,0x38,0x10,0x6F,0xBD,0xD0,0xC6,0xFC,0xDB,0x41,0x47,0xD9,0x81,0x43,0x7F,0x82,0x2E,0x5F,0x86,0xDF,0x53,0x04,0x02,0xEE,
                                                 0xB7,0x8A,0xD5,0x98,0x60,0x71,0x75,0x89,0x04,0xA3,0x0A,0xDB,0x7D,0xF4,0x5C,0x81,0x0B,0x68,0x52,0x49,0xF0,0x78,0x8F,0x7D,0xF4,0xBD,0x98,0xFE,
                                                 0xB4,0x30,0xF8,0xEE,0x5C,0xC2,0x2B,0x1C},
                                                 {0x71,0x4C,0x53,0x58,0xCA,0x5E,0x09,0x68,0x02,0xE7,0xDB,0x6E,0x10,0xA7,0x3A,0xE7,0x60,0xF2,0x22,0xBB,0xAB,0x7D,0xE3,0xC7,0x04,0x34,0x5E,0x06,
                                                 0xDC,0x49,0x9C,0x75,0x55,0x8C,0x8F,0x32,0x73,0x3F,0x5F,0x76,0x58,0x24,0xBC,0x3C,0x9D,0xF0,0x31,0x81,0xAF,0x5B,0xD7,0x3B,0xBC,0x17,0x01,0x8E,
                                                 0x44,0x99,0x97,0x74,0x52,0xC2,0x42,0x68}};
#ifdef INCLUDE_HMAC
const ALIGN uint8_t sha512_hmac[3][CRL_SHA512_SIZE] = {{0xDB,0xEC,0x2A,0x59,0x0C,0xCB,0xDB,0x69,0x02,0xB1,0x87,0x54,0xF2,0x6D,0x74,0xC6,0x0E,0xD2,0x44,0x6D,0x7D,0xDB,0x25,0xD3,0xC9,0x1C,0x02,
                                                 0xB9,0x2F,0x41,0xDF,0xDB,0xAD,0x0A,0x73,0x18,0x47,0x66,0x40,0x2F,0xFC,0x12,0xAA,0x34,0x12,0x81,0xC6,0x15,0x76,0xFA,0xBE,0x8C,0xBA,0x81,
                                                 0x25,0xC7,0x86,0x1D,0xBE,0x95,0x9D,0x40,0xB8,0x73},
                                                 {0x64,0x66,0x6D,0xE1,0x75,0x56,0xE6,0x5E,0x30,0x3D,0x80,0xEB,0x7B,0x68,0x73,0xB9,0xA3,0xA4,0xB3,0xFA,0xBA,0x61,0xDC,0xD8,0x91,0x34,0xED,
                                                 0x64,0xC0,0x79,0xFA,0x52,0xF9,0x2B,0xB5,0xCD,0x8A,0x14,0x52,0xB1,0xA1,0x47,0x5B,0x49,0xED,0xDB,0xD7,0x54,0xB9,0x39,0xC7,0x9D,0x21,0x78,
                                                 0x31,0xF2,0xA9,0xA4,0x49,0xB2,0x5F,0x05,0x95,0x4C},
                                                 {0x93,0x29,0x74,0xF2,0x11,0x1F,0x82,0x54,0x0B,0x5F,0xB5,0xF6,0x70,0x87,0x5B,0xEE,0x70,0x09,0x6A,0x6D,0xF8,0x47,0xBD,0xE9,0x68,0xC9,0xB1,
                                                 0xBA,0x5D,0x34,0x80,0xB3,0xE7,0x93,0xA1,0xEE,0x61,0xB1,0xAE,0x5D,0xF1,0x7D,0xCD,0xE1,0xB2,0xFF,0x4F,0xE6,0x54,0x6E,0xAD,0xF1,0xB9,0x22,
                                                 0xBD,0x3A,0x4A,0x8F,0xCE,0x95,0xA8,0x84,0x14,0x06}};
#endif
#endif

/* Private functions ---------------------------------------------------------*/

uint32_t hash_test( uint32_t verbose )
{
    uint32_t failed = 0;

    /*
    #define nb_sizes 17
    */
    #define nb_sizes 16  /* Only 512K available on telamaco3p esram A7 */
    uint32_t size_len[nb_sizes] = { 1, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 16384, 32768, 65536, 2*65536, 256*1024, 512*1024}; //, 1024*1024 };

#if defined(INCLUDE_SHA384) || defined(INCLUDE_SHA512)
    uint8_t digest[CRL_SHA512_SIZE];
#else
    uint8_t digest[CRL_SHA256_SIZE];
#endif
    uint32_t byte_size;
    uint32_t hash_type = E_SHA1;
    uint32_t loop = 0;
    uint32_t index = 0;

    uint32_t retval = CSE_GENERAL_ERR;
    uint32_t digest_size;

#ifdef PERF_MEASURMENT
    uint64_t delay_ticks;
    uint64_t nanoseconds64;
#endif

    /* Chorus internal flash */
    //uint8_t* input = (uint8_t*)0x00FC0000; /* Flash */

    /* telemaco3p external flash */
    uint8_t* input = (uint8_t*)0x70000000; /* A7 esram - only 512 K available */

    uint32_t nb_loop_to_do = 3;

#ifdef INCLUDE_SHA384
    nb_loop_to_do++;
#endif
#ifdef INCLUDE_SHA512
    nb_loop_to_do++;
#endif

    for(loop = 0; loop < nb_loop_to_do;loop ++)
    {
	printf("\n");

        if(loop == 0)
        {
            if(verbose)
            {
                printf("Testing SHA1 perfs : " );
            }
            hash_type = E_SHA1;
        }
        if(loop == 1)
        {
            if(verbose)
            {
                printf("Testing SHA224 perfs : " );
            }
            hash_type = E_SHA224;
        }
        if(loop == 2)
        {
            if(verbose)
            {
                printf("Testing SHA256 perfs : " );
            }
            hash_type = E_SHA256;
        }
#ifdef INCLUDE_SHA384
        if(loop == 3)
        {
            if(verbose)
            {
                printf("Testing SHA384 perfs : " );
            }
            hash_type = E_SHA384;
        }
#endif
#ifdef INCLUDE_SHA512
        if(loop == 4)
        {
            if(verbose)
            {
                printf("Testing SHA512 perfs : " );
            }
            hash_type = E_SHA512;
        }
#endif
        if(verbose)
        {
            printf("\n");
        }


        for(index = 0; index < nb_sizes; index ++)
        {
            byte_size = size_len[index];

            if(hash_type == E_SHA1)
            {
                retval = CSE_SHA1( (uint8_t*)input, size_len[index], digest, &digest_size );
            }
            if(hash_type == E_SHA224)
            {
                retval = CSE_SHA224( (uint8_t*)input, size_len[index], digest, &digest_size );
            }
            if(hash_type == E_SHA256)
            {
                retval = CSE_SHA256( (uint8_t*)input, size_len[index], digest, &digest_size );
            }
            if(hash_type == E_SHA384)
            {
                retval = CSE_SHA384( (uint8_t*)input, size_len[index], digest, &digest_size );
            }
            if(hash_type == E_SHA512)
            {
                retval = CSE_SHA512( (uint8_t*)input, size_len[index], digest, &digest_size );
            }

            if (retval != CSE_NO_ERR)
            {
                printf("Failed\n");
            }

            printf(" size : %8d bytes, ", byte_size);
	    if (index && (index%4) == 0)
		    printf("\n");

#ifdef PERF_MEASURMENT
            delay_ticks = PIT_perf_net_delta_ticks64(&cmd_start_ts, &cmd_stop_ts);
            nanoseconds64 = PIT_perf_elapsed_nanosec64(delay_ticks);

            printf("elapsed time: ");
            if( delay_ticks > 1000000)
            {
                printf("%8d%06d ticks ",(uint32_t)(delay_ticks/1000000), (uint32_t)(delay_ticks %1000000) );
            }
            else
            {
                printf("%14d ticks ",(uint32_t)(delay_ticks) );
            }

            printf("@%dMHz - ", PIT_freq);

            if(nanoseconds64 > 1000000)
            {
                printf("%8d%06d ns\n", (uint32_t)(nanoseconds64/1000000), (uint32_t)(nanoseconds64 %1000000));
            }
            else
            {
                printf("\%14d ns\n", (uint32_t)(nanoseconds64));
            }
#endif
        }
    }


    HASH_tests(verbose);

    /* return 1 if successful (no test failed) */
    return(failed == 0);
}

uint32_t HASH_tests(uint32_t P_verbose)
{
  uint32_t retval = 0U;

  uint32_t n_tests = 3U;
  int32_t algo = 0U;
  uint32_t test, digest_size;
  uint8_t const *input = NULL, *hash_res = NULL;
  uint32_t input_len = 0;
  uint8_t digest[CRL_SHA512_SIZE]={0,};

#ifdef INCLUDE_HMAC
  uint8_t digest2[CRL_SHA512_SIZE]={0,};
  uint8_t const *key = NULL, *hmac_res = NULL;
  uint32_t key_len = 0;

  uint8_t digest3[CRL_SHA512_SIZE]={0,};
  uint8_t digest4[CRL_SHA512_SIZE]={0,};

  HMAC_MD5ctx_stt HMD5ctx_st;
  HMAC_SHA1ctx_stt HSHA1ctx_st;
  HMAC_SHA224ctx_stt HSHA224ctx_st;
  HMAC_SHA256ctx_stt HSHA256ctx_st;
  HMAC_SHA384ctx_stt HSHA384ctx_st;
  HMAC_SHA512ctx_stt HSHA512ctx_st;
#endif

#ifdef PERF_MEASURMENT
  uint64_t delay_ticks;
  uint64_t nanoseconds64;
#endif

  for (test = 1; test <= n_tests; test++)
  {
    switch (test)
    {
    case 1:
      input = input_1;
      input_len = (uint32_t) sizeof(input_1);
#ifdef INCLUDE_HMAC
      key = key_1;
      key_len = (uint32_t) sizeof(key_1);
#endif
      break;
    case 2:
      input = input_2;
      input_len = (uint32_t) sizeof(input_2);
#ifdef INCLUDE_HMAC
      key = key_2;
      key_len = (uint32_t) sizeof(key_2);
#endif
      break;
    case 3:
      input = input_3;
      input_len = (uint32_t) sizeof(input_3);
#ifdef INCLUDE_HMAC
      key = key_3;
      key_len = (uint32_t) sizeof(key_3);
#endif
      break;
    default:
      continue;
    }

    if (P_verbose)
    {
        printf("\n");
    }

    for (algo = 0; algo < 6; algo++ )
    {
      switch(algo)
      {
#ifdef INCLUDE_SHA1
      case 1:
        if (P_verbose)
        {
            printf("Testing SHA-1\n");
        }
        hash_res = &sha1_hash[test-1][0];

        retval = CSE_SHA1( (uint8_t*)input, input_len, digest, &digest_size );
        if (retval != HASH_SUCCESS) goto err_returned;

#ifdef INCLUDE_HMAC
        hmac_res = &sha1_hmac[test-1][0];

        HSHA1ctx_st.mFlags = E_HASH_DEFAULT;
        HSHA1ctx_st.mTagSize = 16;

        HSHA1ctx_st.pmKey = key;
        HSHA1ctx_st.mKeySize = key_len;
        retval = HMAC_SHA1_Init(&HSHA1ctx_st);
        retval += HMAC_SHA1_Append(&HSHA1ctx_st, input, input_len);
        retval += HMAC_SHA1_Finish(&HSHA1ctx_st, digest3, &outlen);
        if (retval != HASH_SUCCESS) goto err_returned;
        /* Multi Append processing */
        HSHA1ctx_st.mFlags = E_HASH_DEFAULT;
        retval = HMAC_SHA1_Init(&HSHA1ctx_st);
        for (i = 0; i < input_len; i++)
        {
          retval += HMAC_SHA1_Append(&HSHA1ctx_st, input+i, 1);
        }
        retval = HMAC_SHA1_Finish(&HSHA1ctx_st, digest4, &outlen);
        if (retval != HASH_SUCCESS) goto err_returned;

        digest_size = HSHA1ctx_st.mTagSize;
#endif /* HMAC */
        break;
#endif
#ifdef INCLUDE_SHA224
      case 2:
        if (P_verbose)
        {
             printf("Testing SHA-224\n");
        }
        hash_res = &sha224_hash[test-1][0];

        /* Single processing */
        retval = CSE_SHA224( (uint8_t*)input, input_len, digest, &digest_size );
        if (retval != HASH_SUCCESS) goto err_returned;

#ifdef INCLUDE_HMAC
        hmac_res = &sha224_hmac[test-1][0];

        HSHA224ctx_st.mFlags = E_HASH_DEFAULT;
        HSHA224ctx_st.mTagSize = 16;
        HSHA224ctx_st.pmKey = key;
        HSHA224ctx_st.mKeySize = key_len;
        retval = HMAC_SHA224_Init(&HSHA224ctx_st);
        retval += HMAC_SHA224_Append(&HSHA224ctx_st, input, input_len);
        retval += HMAC_SHA224_Finish(&HSHA224ctx_st, digest3, &outlen);
        if (retval != HASH_SUCCESS) goto err_returned;
        /* Multi Append processing */
        HSHA224ctx_st.mFlags = E_HASH_DEFAULT;
        retval = HMAC_SHA224_Init(&HSHA224ctx_st);
        for (i = 0; i < input_len; i++)
        {
          retval += HMAC_SHA224_Append(&HSHA224ctx_st, input+i, 1);
        }
        retval = HMAC_SHA224_Finish(&HSHA224ctx_st, digest4, &outlen);
        if (retval != HASH_SUCCESS) goto err_returned;

        digest_size = HSHA224ctx_st.mTagSize;
#endif /* HMAC */
        break;
#endif
#ifdef INCLUDE_SHA256
      case 3:
        if (P_verbose)
        {
          printf("Testing SHA-256\n");
        }
        hash_res = &sha256_hash[test-1][0];

        /* Single processing */
        retval = CSE_SHA256( (uint8_t*)input, input_len, digest, &digest_size );
        if (retval != HASH_SUCCESS) goto err_returned;


#ifdef INCLUDE_HMAC
        hmac_res = &sha256_hmac[test-1][0];

        HSHA256ctx_st.mFlags = E_HASH_DEFAULT;
        HSHA256ctx_st.mTagSize = 16;
        HSHA256ctx_st.pmKey = key;
        HSHA256ctx_st.mKeySize = key_len;
        retval = HMAC_SHA256_Init(&HSHA256ctx_st);
        retval += HMAC_SHA256_Append(&HSHA256ctx_st, input, input_len);
        retval += HMAC_SHA256_Finish(&HSHA256ctx_st, digest3, &outlen);
        if (retval != HASH_SUCCESS) goto err_returned;
        /* Multi Append processing */
        HSHA256ctx_st.mFlags = E_HASH_DEFAULT;
        retval = HMAC_SHA256_Init(&HSHA256ctx_st);
        for (i = 0; i < input_len; i++)
        {
          retval += HMAC_SHA256_Append(&HSHA256ctx_st, input+i, 1);
        }
        retval = HMAC_SHA256_Finish(&HSHA256ctx_st, digest4, &outlen);
        if (retval != HASH_SUCCESS) goto err_returned;

        digest_size = HSHA256ctx_st.mTagSize;
#endif /* HMAC */
        break;
#endif
#ifdef INCLUDE_SHA384
      case 4:
        if (P_verbose)
        {
            printf("Testing SHA-384\n");
        }
        hash_res = &sha384_hash[test-1][0];

        /* Single processing */
        retval = CSE_SHA384( (uint8_t*)input, input_len, digest, &digest_size );
        if (retval != HASH_SUCCESS) goto err_returned;

#ifdef INCLUDE_HMAC
        hmac_res = &sha384_hmac[test-1][0];

        HSHA384ctx_st.mFlags = E_HASH_DEFAULT;
        HSHA384ctx_st.mTagSize = 48;
        HSHA384ctx_st.pmKey = key;
        HSHA384ctx_st.mKeySize = key_len;
        retval = HMAC_SHA384_Init(&HSHA384ctx_st);
        retval += HMAC_SHA384_Append(&HSHA384ctx_st, input, input_len);
        retval += HMAC_SHA384_Finish(&HSHA384ctx_st, digest3, &outlen);
        if (retval != HASH_SUCCESS) goto err_returned;
        /* Multi Append processing */
        HSHA384ctx_st.mFlags = E_HASH_DEFAULT;
        retval = HMAC_SHA384_Init(&HSHA384ctx_st);
        for (i = 0; i < input_len; i++)
        {
          retval += HMAC_SHA384_Append(&HSHA384ctx_st, input+i, 1);
        }
        retval = HMAC_SHA384_Finish(&HSHA384ctx_st, digest4, &outlen);
        if (retval != HASH_SUCCESS) goto err_returned;

        digest_size = HSHA384ctx_st.mTagSize;
#endif /* HMAC */
        break;
#endif
#ifdef INCLUDE_SHA512
      case 5:
        if (P_verbose)
        {
            printf("Testing SHA-512\n");
        }
        hash_res = &sha512_hash[test-1][0];
        /* Single processing */
        retval = CSE_SHA512( (uint8_t*)input, input_len, digest, &digest_size );
        if (retval != HASH_SUCCESS) goto err_returned;

#ifdef INCLUDE_HMAC
        hmac_res = &sha512_hmac[test-1][0];

        HSHA512ctx_st.mFlags = E_HASH_DEFAULT;
        HSHA512ctx_st.mTagSize = 64;
        HSHA512ctx_st.pmKey = key;
        HSHA512ctx_st.mKeySize = key_len;
        retval = HMAC_SHA512_Init(&HSHA512ctx_st);
        retval += HMAC_SHA512_Append(&HSHA512ctx_st, input, input_len);
        retval += HMAC_SHA512_Finish(&HSHA512ctx_st, digest3, &outlen);
        if (retval != HASH_SUCCESS) goto err_returned;
        /* Multi Append processing */
        HSHA512ctx_st.mFlags = E_HASH_DEFAULT;
        retval = HMAC_SHA512_Init(&HSHA512ctx_st);
        for (i = 0; i < input_len; i++)
        {
          retval += HMAC_SHA512_Append(&HSHA512ctx_st, input+i, 1);
        }
        retval = HMAC_SHA512_Finish(&HSHA512ctx_st, digest4, &outlen);
        if (retval != HASH_SUCCESS) goto err_returned;

        digest_size = HSHA512ctx_st.mTagSize;
#endif /* HMAC */
        break;
#endif

      default:
        continue;
      }
    if (P_verbose)
    {
#ifdef PERF_MEASURMENT
        delay_ticks = PIT_perf_net_delta_ticks64(&cmd_start_ts, &cmd_stop_ts);
        nanoseconds64 = PIT_perf_elapsed_nanosec64(delay_ticks);

        printf("elapsed time: ");
        if( delay_ticks > 1000000)
        {
            printf("%8d%06d ticks ",(uint32_t)(delay_ticks/1000000), (uint32_t)(delay_ticks %1000000) );
        }
        else
        {
            printf("%8d ticks ",(uint32_t)(delay_ticks) );
        }

        printf("@%dMHz - ", PIT_freq);

        if(nanoseconds64 > 1000000)
        {
            printf("%8d%06d ns\n", (uint32_t)(nanoseconds64/1000000), (uint32_t)(nanoseconds64 %1000000));
        }
        else
        {
            printf("\%14d ns\n", (uint32_t)(nanoseconds64));
        }
#endif
    }

      if (P_verbose)
      {
          printf("with message of %d bytes with a single append...", input_len);
      }
      if (memcmp(digest, hash_res, digest_size) != 0)
      {
          if (P_verbose)
          {
              printf("Error! Incorrect digest\n");
              print_buffer("Expected Digest:",hash_res,digest_size);
              print_buffer("Returned Digest:",digest,digest_size);
          }
          return(-1);
      }
      else
      {
          if (P_verbose)
          {
               printf("OK!\n");
          }
      }

#ifdef INCLUDE_HMAC
      printf("with message of %d bytes with key of length %d with a single DMA append...", input_len, key_len);
      if (memcmp(digest3, hmac_res, digest_size) != 0)
      {
        printf("Error! Incorrect HMAC\n");
        print_buffer("Expected HMAC:",hmac_res,digest_size);
        print_buffer("Returned HMAC:",digest3,digest_size);
        return(-1);
      }
      else
      {
        printf("OK!\n");
      }
/*      printf("with message of %d bytes with key of length %d with multiple appends...", input_len, key_len);
      if (memcmp(digest4, hmac_res, digest_size) != 0)
      {
        printf("Error! Incorrect HMAC\n");
        print_buffer("Expected HMAC:",hmac_res,digest_size);
        print_buffer("Returned HMAC:",digest4,digest_size);
        return(-1);
      }
      else
      {
        printf("OK!\n");
      }
      */
#endif
    }
  }
  goto no_errors;

err_returned:
    if (P_verbose)
    {
        printf("Some test has FAILED. The error %d has been returned\n",retval);
    }
  return(0);
no_errors:
  return (1);
}

/**
 * @}
 */
