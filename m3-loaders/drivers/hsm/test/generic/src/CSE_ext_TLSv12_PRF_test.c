/*
 * CSE_ext_TLSv12_PRF_test.c
 *
 *  Created on: 3 avr. 2018
 */
/**
 * @file    CSE_ext_TLSv12_PRF_test.c
 * @brief   TLS V1.2 PRF secret generation tests
 * @details
 *
 *
 * @addtogroup CSE_driver_test
 * @{
 */

#include <string.h>

#include "config.h"
#include "serialprintf.h"

#include "cse_types.h"
#include "CSE_ext_TLSv12_PRF.h"
#include "CSE_ext_TLSv12_PRF_test.h"
#include "CSE_ext_TLSv12_PRF_TV.h"
#include "CSE_Constants.h"

#include "CSE_ext_test_globals.h"

#include "CSE_extendKey_updateSupport.h"
#include "CSE_Manager.h"
#include "CSE_extendKey_updateSupport.h"

#include "err_codes.h"
/******************************************************************************/
/****************************** TLS V1.2 PRF Test Vectors *********************/
/******************************************************************************/
extern const tlsv12_prf_stt tlsv12_prf_testVectors[];

/**
  * @brief  TLS V1.2 secret generation Test
  *
  * @param verbose
  *
  * @retval error status: ECC_SUCCESS, ECC_ERR_BAD_PARAMETER, CSE_GENERAL_ERR
*/

uint32_t tlsv12_prf_test(uint32_t P_verbose)
{
    uint32_t status = 0U;
#define buffLength 256

    uint8_t prfResult[buffLength] = {0U,};     /* Buffer that will contain result of ECDH operation */

    struct TLS_PRF_Secret inputSecret;  /* Input secret: pre-master key or master key */
    struct TLS_PRF_Label label;         /* TLS Label */
    struct TLS_PRF_Seed seed;           /* TLS Seed */
    struct TLS_PRF_PrfOutput prfOutput; /* Secret generated by PRF */

    int32_t check;
    uint32_t failed = 0U;
    uint32_t tv = 0U;

    if(P_verbose)
    {
        printf("\n");
        printf("TLS V1.2 PRF Secret generation Tests !\n");
        printf("Test against Known Answer Test Vectors  !\n");
    }

    for(tv = 0U; tv < C_NB_TEST_TLSv12_PRF_TV; tv ++)
    {
        /* Erase buffer */
        uint32_t i = 0U;
        for (i = 0U; i < buffLength; i++)
        {
            prfResult[i] = 0U;
        }
        /* Initialize Inputs with values from test vectors */
        inputSecret.address = (uint8_t*)tlsv12_prf_testVectors[tv].pSecret;
        inputSecret.byteSize = tlsv12_prf_testVectors[tv].secretSize;

        label.address = (uint8_t*)tlsv12_prf_testVectors[tv].pLabel;
        label.byteSize = tlsv12_prf_testVectors[tv].labelSize;

        seed.address = (uint8_t*)tlsv12_prf_testVectors[tv].pSeed;
        seed.byteSize = tlsv12_prf_testVectors[tv].seedSize;

        prfOutput.address = prfResult;
        prfOutput.byteSize = tlsv12_prf_testVectors[tv].expectedPrfOutputSize;

        *(uint32_t *)&(prfOutput).address[0] = buffLength;

        status = CSE_TLSv12_prf(&inputSecret, &label, &seed, tlsv12_prf_testVectors[tv].shaID, &prfOutput);
        if (CSE_NO_ERR == status)
        {
            /* Compare with expected results  from test vectors */
            check = memcmp(prfResult, (uint8_t*)tlsv12_prf_testVectors[tv].pExpectedPrfOutput, tlsv12_prf_testVectors[tv].expectedPrfOutputSize);
            if(P_verbose)
            {
                printf("TLS V1.2 PRF result check: %d (expected: 1)\n", check == 0);
            }
        }
        else
        {
            if(P_verbose)
            {
                printf("TLS V1.2 PRF generation Failed.\n");
            }
        }

            /* Set Error Flag */
            failed += ((CSE_NO_ERR != status) || ((CSE_NO_ERR == status) && (0 != check)));

    }

    /* return 1 if successful (no test Failed) */
    return(failed == 0);
} /* End of tlsv12_prf_test */

/**
 * @}
 */

